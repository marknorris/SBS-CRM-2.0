{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab560
\pard\tx560\pardeftab560\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0 \
refresh table view:\
\
    \cf2 /*\
    //isMutatingArray = YES;\
    //[[NSNotificationCenter defaultCenter] \
    // postNotificationName:@"reloadCoreData" \
    // object:self];\
    [eventIDArray removeAllObjects];\
    \
    if (context == nil) \{ context = [(AppDelegate *)[[UIApplication sharedApplication] delegate] managedObjectContext]; \}\
    \
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"Event" inManagedObjectContext:context];\
    NSFetchRequest *request = [[NSFetchRequest alloc] init];\
    // max number to load:\
    //[request setFetchBatchSize:<#(NSUInteger)#>];\
    \
    [request setEntity:entity];\
    \
    //create and set sort descriptors to order array by due date and time.\
    NSSortDescriptor *dateSortDescriptor = [[NSSortDescriptor alloc]\
                                        initWithKey:@"eveDueDate" ascending:YES];\
    NSSortDescriptor *timeSortDescriptor = [[NSSortDescriptor alloc]\
                                            initWithKey:@"eveDueTime" ascending:YES];\
    [request setSortDescriptors:[NSArray arrayWithObjects:dateSortDescriptor,timeSortDescriptor,nil]];\
\
    \
    NSError *error = nil;\
    NSArray *eventsArray = [context executeFetchRequest:request error:&error];\
    \
    if ([eventsArray count] == 0)\
    \{\
        //TODO: see if i need this: it checks to see if the array is empty, and if it is it reloads the data. when there was no data it entered an endless loop.\
        //[self startLoading];\
        //once the tableview has data in it, scroll to today (or soonest day after)\
        isMutatingArray = NO;\
        [self.tableView reloadData];\
        if (isLoading)\
            [self stopLoading];\
        return;\
    \}\
    \
    \
    //TODO make the for below better!\
    \
    //set up the date formatters\
    NSDateFormatter *df = [[NSDateFormatter alloc] init];\
    [df setDateStyle:NSDateFormatterMediumStyle];\
    NSDateFormatter *dfToDate = [[NSDateFormatter alloc] init];\
    [dfToDate setDateFormat:@"dd/MM/yyyy"];\
    \
    Event *event = [eventsArray objectAtIndex:0];\
    NSDate *currentDate = event.eveDueDate;\
    NSMutableArray *tempIDArray = [[NSMutableArray alloc] init];\
    for (int i = 0; i < [eventsArray count]; i++)\
    \{\
        NSLog(@"currentDate:%@", currentDate);\
        event = [eventsArray objectAtIndex:i];\
        if ([event.eveDueDate isEqualToDate:currentDate])\
            [tempIDArray addObject:event.eventID];\
        else\
        \{\
            NSString *dateString;\
\
            if ([currentDate isEqualToDate:[dfToDate dateFromString:@"01/01/9999"]] || currentDate == NULL)\
                dateString = @"No Due Date";\
            else \
                dateString = [df stringFromDate:currentDate];\
            NSLog(@"date string: %@", dateString);\
            NSDictionary *dict = [NSDictionary dictionaryWithObject:tempIDArray forKey:dateString];\
            [eventIDArray addObject:dict];\
            tempIDArray = [[NSMutableArray alloc] init];\
            [tempIDArray addObject:event.eventID];\
            currentDate = event.eveDueDate;\
        \}\
    \}\
    \
    //for last one\
    NSString *dateString;\
    dateString = [df stringFromDate:currentDate];\
    if ([currentDate isEqualToDate:[dfToDate dateFromString:@"01/01/9999"]] || currentDate == NULL)\
        dateString = @"No Due Date";\
    NSDictionary *dict = [NSDictionary dictionaryWithObject:tempIDArray forKey:dateString];\
    [eventIDArray addObject:dict];\
     \
    */\cf0  \
\
\
\
\
view did appear:\
    \
    \
    \cf2 // load data from the server (via pull to refresh method)\cf0 \
    \cf2 //[self startLoading];\cf0 \
    \
    \cf2 /*\
    if (context == nil) \{ context = [(AppDelegate *)[[UIApplication sharedApplication] delegate] managedObjectContext]; \}\
    \
    NSEntityDescription *entity;\
    NSFetchRequest *request;\
    NSError *error; \
    NSMutableArray *arr;\
    \
    //log events count\
    \
    entity = [NSEntityDescription entityForName:@"Events" inManagedObjectContext:context];\
    request = [[NSFetchRequest alloc] init];\
    [request setEntity:entity];\
    arr = [[context executeFetchRequest:request error:&error] mutableCopy];\
    NSLog(@"Events:%d", arr.count);\
    \
    //log Company count\
    \
    entity = [NSEntityDescription entityForName:@"Company" inManagedObjectContext:context];\
    request = [[NSFetchRequest alloc] init];\
    [request setEntity:entity]; \
    arr = [[context executeFetchRequest:request error:&error] mutableCopy];\
    NSLog(@"Company:%d", arr.count);\
    \
    //log Contact count\
    \
    entity = [NSEntityDescription entityForName:@"Contact" inManagedObjectContext:context];\
    request = [[NSFetchRequest alloc] init];\
    [request setEntity:entity]; \
    arr = [[context executeFetchRequest:request error:&error] mutableCopy];\
    NSLog(@"Contact:%d", arr.count);\
    \
    //log Communication count\
    \
    entity = [NSEntityDescription entityForName:@"Communication" inManagedObjectContext:context];\
    request = [[NSFetchRequest alloc] init];\
    [request setEntity:entity]; \
    arr = [[context executeFetchRequest:request error:&error] mutableCopy];\
    NSLog(@"Communication:%d", arr.count);\
    \
    //log Attachment count\
    \
    entity = [NSEntityDescription entityForName:@"Attachment" inManagedObjectContext:context];\
    request = [[NSFetchRequest alloc] init];\
    [request setEntity:entity]; \
    arr = [[context executeFetchRequest:request error:&error] mutableCopy];\
    NSLog(@"Attachment:%d", arr.count);\
    \
\
    */\cf0 \
\
\
\
\
// customer section headers\
\cf2 /*\
- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section\
\{\
    // create the parent view that will hold header Label\
	UIView* customView = [[UIView alloc] initWithFrame:CGRectMake(0.0, 0.0, 0.0, 0.0)];\
	\
    if (section == 5)\
    \{\
\
	// create the button object\
	UILabel * headerLabel = [[UILabel alloc] initWithFrame:CGRectZero];\
	headerLabel.backgroundColor = [UIColor clearColor];\
	headerLabel.opaque = NO;\
	headerLabel.textColor = [UIColor blackColor];\
	headerLabel.highlightedTextColor = [UIColor whiteColor];\
	headerLabel.font = [UIFont boldSystemFontOfSize:20];\
	headerLabel.frame = CGRectMake(10.0, 0.0, 300.0, 44.0);\
    \
	// If you want to align the header text as centered\
	// headerLabel.frame = CGRectMake(150.0, 0.0, 300.0, 44.0);\
    \
	headerLabel.text = @"testing"; // i.e. array element\
	[customView addSubview:headerLabel];\
    	return customView;\
    \}\
        \
    return nil;\
\}\
*/\cf0 \
\
\
\
\cf2 /*\
// Override to support conditional editing of the table view.\
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath\
\{\
    // Return NO if you do not want the specified item to be editable.\
    return YES;\
\}\
*/\cf0 \
\
\cf2 /*\
// Override to support editing the table view.\
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath\
\{\
    if (editingStyle == UITableViewCellEditingStyleDelete) \{\
        // Delete the row from the data source\
        [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];\
    \}   \
    else if (editingStyle == UITableViewCellEditingStyleInsert) \{\
        // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view\
    \}   \
\}\
*/\cf0 \
\
\cf2 /*\
// Override to support rearranging the table view.\
- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath\
\{\
\}\
*/\cf0 \
\
\cf2 /*\
// Override to support conditional rearranging of the table view.\
- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath\
\{\
    // Return NO if you do not want the item to be re-orderable.\
    return YES;\
\}\
*/\
\
\
\
\
\cf0 /*\
//########## SEARCH ############\cf2 \
- (void) searchBarTextDidBeginEditing:(UISearchBar *)searchBar \{\
    isSearching = YES;\
\}\
\
- (void) searchBarCancelButtonClicked:(UISearchBar *)searchBar \{\
    isSearching = NO;\
    [searchResults removeAllObjects];\
    [self.searchDisplayController.searchResultsTableView reloadData];\
\}\
\
//when the search result changes delete all of the currently displayed results.\
- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText \{\
    if ([searchText length] == 0)\
    \{\
        [searchResults removeAllObjects];\
        [self.searchDisplayController.searchResultsTableView reloadData];    \
    \}\
\}\
\
\
- (void) searchBarSearchButtonClicked:(UISearchBar *)searchBar1 \{\
    [searchResults removeAllObjects];\
    [self.searchDisplayController.searchResultsTableView reloadData];\
    [self filterContentForSearchText:searchBar.text \
                               scope:[[self.searchDisplayController.searchBar scopeButtonTitles]\
                                      objectAtIndex:[self.searchDisplayController.searchBar\
                                                     selectedScopeButtonIndex]]];\
    [self.searchDisplayController.searchResultsTableView reloadData];\
\}\
\
- (BOOL)searchDisplayController:(UISearchDisplayController *)controller \
shouldReloadTableForSearchScope:(NSInteger)searchOption\
\{\
    //[self filterContentForSearchText:[self.searchDisplayController.searchBar text] \
    //scope:[[self.searchDisplayController.searchBar scopeButtonTitles]\
    //objectAtIndex:searchOption]];\
    [searchResults removeAllObjects];\
    [self filterContentForSearchText:searchBar.text \
                               scope:[[self.searchDisplayController.searchBar scopeButtonTitles]\
                                      objectAtIndex:[self.searchDisplayController.searchBar\
                                                     selectedScopeButtonIndex]]];\
    [self.searchDisplayController.searchResultsTableView reloadData];\
    return YES;\
\}\
\
-(BOOL)searchDisplayController:(UISearchDisplayController *)controller \
shouldReloadTableForSearchString:(NSString *)searchString\
\{\
    return NO;\
\}\
\
- (void)filterContentForSearchText:(NSString*)searchText \
                             scope:(NSString*)scope\
\{\
    // remove previous search results.\
    [searchResults removeAllObjects];\
    //create array of objectes to search\
    NSMutableArray *searchArray = [[NSMutableArray alloc] init];\
    /*\
    for ()\
        \
\
    \
    for (NSInteger j = 0; j < [fTweets count]; j++)\
    \{\
        NSDictionary *dict = [fTweets objectAtIndex:j];\
        NSArray *keys = [dict allKeys];\
        id key = [keys objectAtIndex:0];\
        NSArray *array = [dict objectForKey:key];\
        \
        [searchArray addObjectsFromArray:array];\
    \}\
    \
    \
    for (Tweet *tTemp in searchArray)\
    \{\
        \
        NSString *sTemp  = @"";\
        if ([scope isEqualToString:@"Username"])\
        \{\
            sTemp = tTemp.userName;\
        \}\
        else if ([scope isEqualToString:@"Text"])\
        \{\
            sTemp = tTemp.text;\
        \}\
        else if ([scope isEqualToString:@"Both"])\
        \{\
            sTemp = tTemp.text;\
            sTemp = [sTemp stringByAppendingString:tTemp.userName];\
        \}\
        NSRange titleResultsRange = [sTemp rangeOfString:searchText options:NSCaseInsensitiveSearch];\
        \
        if (titleResultsRange.length != 0)\
        \{\
            NSLog (@"username: %@", tTemp.userName);\
            [searchResults addObject:tTemp];\
            //NSLog (@"count: %@", [searchResults count]);\
        \}\
    \}\
    \
    \
    [searchArray removeAllObjects] ;\
    [self.searchDisplayController.searchResultsTableView reloadData];\
     \
\}\
//########## END SEARCH ############\
*/\cf0 \
\
\
\
\
\
\
\
\
cell for row\
\
        \cf2 /*\
        EventsCellData* currentCell = [[EventsCellData alloc] init];\
        currentCell.eventTitle = event.eveTitle;\
        currentCell.eventComments = event.eveComments;\
        currentCell.eventTypeType2 = cell.eventTypeType2.text;\
        currentCell.siteNameDesc = cell.siteNameDesc.text;\
        currentCell.eventDueTime = cell.eventDueTime.text;\
        [allEventsArray addObject:currentCell];\
        NSLog(@"COUNT OF EVENT CELL DATA: %d", [allEventsArray count]);\
        */\
\
\
\
\
\
\
\
\
\
\
\
\
\
\cf0     \
    \cf2 /*\
    //reload data from server asynchronously\
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^\{  \
        //return result of sync to reloaded - NO = failed, YES = success.\
        [UIApplication sharedApplication].idleTimerDisabled = YES;\
        BOOL reloaded =  [[syncData alloc] doSync];\
        dispatch_sync(dispatch_get_main_queue(), ^\{\
            if (!reloaded)\
            \{\
                [UIApplication sharedApplication].idleTimerDisabled = NO;\
                [self stopLoading];\
                //alert user the are not connected to the server\
                UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Fetch data" message:@"Could not connect to server" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];\
                [alert show];\
            \}\
            else\
            \{\
                //TODO check this -- cause error when it tried to reload after the if statement and there was no data!\
                // put the data into the table\
                [UIApplication sharedApplication].idleTimerDisabled = NO;\
                [self refreshTableView];\
                [self performSelector:@selector(scrollToToday) withObject:nil afterDelay:0.5];\
            \}\
            //TODO check whether this line is needed:\
            //self.tableView.scrollEnabled = YES;\
        \});\
    \});*/}